# 深入浅出STL（一）

在这个项目中，我主要参考了侯捷老师的《STL 源码剖析》，并借鉴了书中提及的 SGI STL 以及 GitHub 上的 MyTinySTL 项目。目前，我已经完成了 `vector` 的一些基本操作，尽管如此，我已经学到了很多。在从未深入学习到逐渐掌握的过程中，我对后续的工作有了清晰的思路，因此决定在此告一段落。

在完成这个项目的过程中，我对 STL 的工作方式有了更深刻的理解。我学会了内存池的概念，甚至考虑模仿一些流行的内存池代码再做一个。此外，我对模板元编程也有了更深入的认识，解决了之前一些模棱两可的模板写法问题。

## 1. STL 是什么？

在认真了解之前，我对 STL 的理解仅限于一些常见的容器如 `vector`、`map`、`set` 等。然而，STL 远不止这些。STL（Standard Template Library）是一套功能强大的程序库，提供了以下六个主要组件：

- **容器（Containers）**：用于存储和组织数据，如 `vector`、`list`、`deque` 等。
- **算法（Algorithms）**：处理数据的通用算法，如排序、搜索、变换等。
- **迭代器（Iterators）**：连接容器与算法的桥梁，提供了统一的访问方式。
- **仿函数（Functors）**：类似于函数的对象，可以像函数一样被调用。
- **适配器（Adapters）**：将一种接口转换为另一种接口，使不同组件之间能够协同工作。
- **分配器（Allocators）**：负责内存的分配和管理。

其中，容器、算法和迭代器是我相对熟悉的部分，而分配器、仿函数和适配器则相对陌生。了解这些组件的存在及其重要性是进一步理解 STL 的关键。尤其是分配器的存在意义是什么？接下来，我们将从分配器（Allocator）开始，逐步揭开 STL 的神秘面纱。

## 2. 构造函数中隐藏的默认参数：分配器

在 STL 中，几乎所有的容器类（如 `vector`、`list`、`map` 等）都在构造函数中接受一个名为“分配器（Allocator）”的参数。这个分配器负责管理内存的分配和释放，而标准库提供的默认分配器 `std::allocator` 通常已经足够使用。因此，容器的构造函数通常隐藏了这个参数，使得用户不必明确传递它。以 SGI STL 的代码为例：

```cpp
template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp)>
class vector : protected _Vector_base<_Tp, _Alloc> {
  //...
}
```

第二个默认的模板参数 `__STL_DEFAULT_ALLOCATOR(_Tp)` 就是 SGI STL 默认的空间配置器。既然 STL 容器默认使用分配器，那么自然会引发一个问题：为什么需要专门的分配器，而不是直接使用 C++ 中常见的 `new` 操作符呢？要回答这个问题，我们首先需要深入理解 `new` 的工作原理及其局限性。

## 3. `new` 操作符的工作原理

在 C++ 中，`new` 实际上有三种主要形式：`new` 操作符、`operator new` 函数和 `placement new`。理解这三种形式有助于我们更好地理解为什么 STL 需要分配器。

### 3.1 `new` 操作符

这是最常用的形式：

```cpp
int* p = new int(10);
```

`new` 操作符完成了两件事：1. 分配内存；2. 在分配的内存上构造对象。

### 3.2 `operator new` 函数

这是一个可以被重载的函数：

```cpp
void* operator new(size_t size);
```

`operator new` 只负责分配内存，不调用构造函数。它通常被 `new` 操作符在内部调用。

### 3.3 `placement new`

这是 `new` 操作符的一个特殊版本，允许我们在预先分配的内存上构造对象：

```cpp
char* buffer = new char[sizeof(MyClass)];
MyClass* obj = new (buffer) MyClass();
```

`placement new` 不分配新内存，只在指定的内存位置上调用构造函数。它主要用于精细控制对象的生命周期和内存使用，例如在嵌入式系统或性能要求极高的应用中。

## 4. 为什么需要分配器？

尽管 `new` 操作符可以完成内存分配和对象构造的功能，但它还是存在一些局限性：

- **效率问题**：`new` 操作符每次都需要向操作系统申请内存，这个过程开销较大。而分配器可以采用内存池技术，预先分配一块大内存，然后在这块内存上进行快速分配。
- **灵活性问题**：`new` 操作符无法满足不同容器对内存分配的个性化需求，如对齐要求、内存碎片管理等。分配器可以根据具体需求实现定制化的内存管理策略。
- **复杂性问题**：将内存管理的细节封装在分配器中，可以简化容器的实现，使得容器的代码更加简洁和通用。

在 STL 中，分配器的主要职责是管理内存的分配和释放。标准库的默认分配器 `std::allocator` 提供了一种通用的内存管理方式，它使用了底层的 `new` 和 `delete` 操作符。然而，开发者可以根据特定需求`自定义`分配器，从而在特定场景下实现更复杂的内存管理策略，如内存池。通过自定义分配器，可以为不同的容器定制专门的内存管理机制，以此提高内存分配的效率和整体性能。

### 4.1 内存池概念

内存池（Memory Pool）是一种内存分配策略，旨在提高动态内存分配的效率。它的基本思想是预先分配一大块内存，然后将这块内存分成多个小块进行管理。当程序需要分配内存时，直接从预分配的内存池中获取，而不是每次都向操作系统申请。这样做有以下几个优点：

1. **减少系统调用**：预分配大块内存减少了向操作系统申请内存的次数，降低了系统调用的开销。
2. **提高分配速度**：从预分配的内存中分配小块内存通常比直接调用 `new` 或 `malloc` 更快。
3. **减少内存碎片**：通过统一管理内存，可以更好地控制内存布局，减少内存碎片的产生。
4. **更好的缓存局部性**：预分配的内存往往在物理内存上是连续的，有利于提高缓存命中率。
5. **自定义内存管理策略**：可以根据具体应用场景优化内存分配策略，如为特定大小的对象预留内存块。

### 4.2 高频交易系统中的订单管理

想象一个场景：我们正在开发一个高性能的股票交易系统，需要频繁地创建和销毁大量的小对象（比如交易订单）。在这种情况下，STL 分配器的优势就变得非常明显。

假设我们有一个 `TradeOrder` 类：

```cpp
class TradeOrder {
    std::string stockSymbol;
    double price;
    int quantity;
    // 其他成员...
};
```

在传统方法中，我们可能会这样管理订单：

```cpp
std::vector<TradeOrder*> orders;

// 创建新订单
orders.push_back(new TradeOrder());

// 处理完订单后
for (auto order : orders) {
    delete order;
}
orders.clear();
```

这种方法在高频交易环境下可能会遇到以下问题：

1. 频繁的内存分配和释放会导致内存碎片。
2. 系统调用（如 `malloc`/`free`）的开销会累积，影响性能。

现在，来看一下使用 STL 分配器的方案：

```cpp
#include <memory>
#include <vector>

// 自定义分配器，使用内存池技术
template <typename T>
class PoolAllocator {
    // 实现内存池逻辑...
public:
    T* allocate(std::size_t n) {
        // 从内存池中分配内存
    }
    void deallocate(T* p, std::size_t n) {
        // 将内存返回到内存池
    }
    // 其他必要的方法...
};

// 使用自定义分配器的 vector
std::vector<TradeOrder, PoolAllocator<TradeOrder>> orders;

// 创建新订单
orders.emplace_back(); // 直接在 vector 中构造对象

// 处理完订单后
orders.clear(); // 自动调用析构函数并将内存返回到内存池
```

这种方法的优势：

1. **内存重用**：`PoolAllocator` 可以维护一个内存池，减少系统调用和内存碎片。
2. **批量分配**：可以预先分配大块内存，减少分配次数。
3. **缓存局部性**：相关的对象更可能被分配在相邻的内存位置，提高缓存命中率。
4. **自定义策略**：可以根据特定需求（如对象大小、生命周期）优化分配策略。
5. **异常安全**：STL 容器会正确处理异常，确保资源不会泄露。

在这个高频交易的例子中，使用自定义的 STL 分配器可以显著提高系统的性能和稳定性。通过减少内存碎片、降低系统调用开销，并提高内存访问的局部性，我们可以处理更多的交易订单，同时保持较低的延迟。

### 4.3 多线程环境中的分配器

在多线程环境下使用分配器时，需要特别注意线程安全问题。标准的 `std::allocator` 在多线程下是安全的，但自定义分配器在设计时需要考虑同步机制，以确保在多线程并发访问时不会引发竞态条件或数据损坏。
